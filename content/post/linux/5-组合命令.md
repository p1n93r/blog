---
typora-root-url: ../../../static
title: "5-组合命令"
date: 2019-11-25T20:40:36+08:00
draft: false
categories: ["Linux"]
---

## 连续运行多个命令
可以使用符号 `;` 分隔多个连续运行的命令。例如下面：

![;分隔命令][p0]

***Notice*** ：使用此种方式连续运行多个命令的时候，需要特别小心—— **即使前面的命令运行失败，后面的命令也会按顺序执行** 。

## 仅在前面的命令运行成功时才运行下一条命令
如果使用 `;` 分隔多个顺序执行的命令，不管前面的命令是否执行失败，后面的命令都会得到执行，这会造成一些不好的影响，所以更好的分隔办法是使用 `&&` 来对多个命令进行分隔。如此，只有前面的命令成功执行，后面的命令才会得到执行。例子如下：

![&&分隔命令][p1]

## 仅在前面的命令运行失败时才运行下一条命令
使用 `||` 分隔多个连续的命令，只有当前面的命令运行失败时后面的命令才会运行。常常用此方式实现方法执行失败发送警告。一个综合对比的例子如下：

![||分隔][p2]

## 将一条命令的输出插入另一条命令
可以使用符号 `$()` 将括号内的命令输出作为另一条命令的组成，如下：

![$()的使用][p3]

## 将一条命令的输出做为另一条命令的输入
要想实现这个目的，可以使用管道 `|` ，它位于两个命令之间，将第一个命令的输出作为第二个命令的输入，换句话说，管道将stdout重定向到第二条命令的stdin。一个例子如下：

![管道|][p4]

## 将命令的输出重定向到文件
使用符号 `>` 可以将标准输出重定向到文件（此文件可以不必存在，会自定创建。 **但是如果存在的话，会覆盖该文件的内容** ）。一个例子如下：

![重定向到文件][p5]

## 防止重定向时覆盖文件
上面使用 `>` 重定向到文件输出时，如果文件原本存在内容，则会覆盖原文件，所以为了防止被覆盖，可以使用命令 `set -o noclobber` 来设置bash不允许重定向覆盖已经存在的文件，如果要关闭，则将 `-o` 改为 `+o` 。当开启时，如果还想重定向覆盖源文件，则需要使用 `>|` 代替 `>` 。一个例子如下：

![set -o noclobber][p6]

## 将命令的输出追加到文件
使用 `>` 重定向到文件会默认覆盖文件，但是使用 `>>` 重定向到文件，可以不覆盖而是追加到文件末尾。一个例子如下：

![>>的使用][p7]

## 将文件用作命令的输入
使用符号 `<` 可以重定向stdin，一个例子如下：

![<的使用][p8]

## 结合使用输入和输出重定向
符号 `<` 和 `>`（或者 `>>` ） 可以结合使用，一个例子如下：

![结合使用输入和输出重定向][p9]

## 将输出同时发送到文件和stdout
可以使用 `tee` 命令将输出拆分为两个流：①stdout ②文件。 **如果写入的文件已经存在，则系统将使用tee提供的新数据覆盖该文件，此时可以使用其 `-a` 选项将数据追加到文件而不是覆盖** 。一个简单的例子如下：

![tee的使用][p10]




[p0]:/media/20191125-1.png
[p1]:/media/20191125-2.png
[p2]:/media/20191125-3.png
[p3]:/media/20191125-4.png
[p4]:/media/20191125-5.png
[p5]:/media/20191125-6.png
[p6]:/media/20191125-7.png
[p7]:/media/20191125-8.png
[p8]:/media/20191125-9.png
[p9]:/media/20191125-10.png
[p10]:/media/20191125-11.png