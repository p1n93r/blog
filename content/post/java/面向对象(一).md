---
typora-root-url: ../../../static
title: "面向对象(一)"
date: 2019-09-25T10:31:36+08:00
lastmod: 2019-09-25T21:52:36+08:00
draft: false
categories: ["Java"]
---

## 概述
- 面向对象三大特征： **封装，继承，多态**
- 类可以被认为是一种自定义的数据类型，可以使用类来定义变量，所有使用类定义的变量都是 **引用变量** ，他们将会引用到类的对象。
- **初始化块** 总是在构造器执行之前被调用
- **静态初始化** 块用于初始化类，在类初始化阶段被执行

## 关于类的知识点
- 所有类都是引用类型
- 类的修饰符只能是：public,default,abstract,final
- **类内的static就是为了区分被修饰的东西是属于类的，还是属于类的对象的**
- static修饰的成员不能访问没有static修饰的成员
- 如果一个类没有写构造器，那么系统将提供一个默认的无参构造器。但是一旦写了构造器，系统将不再提供默认构造器
- 类的属性的修饰符只能是：public,default,protected,private,static,final.前四个最多只能出现一个，可以与static,final组合起来使用
- 类的属性包括： **类变量** 和 **实例变量** ,用static的修饰的属性就是类变量
- 类的构造器的修饰符只能是：public,default,protected,private三者之一
- 声明类的构造器的时候， **不要声明返回值** ，如果写的构造方法写了返回值，则会被当成普通方法编译
- 静态变量和静态方法可以直接被类调用，也可以被类的对象调用

## 对象，引用，指针知识点
1. java不能直接访问堆内存中的对象，只能通过该对象的引用操作对象
2. 堆内存的对象可以有多个引用，即多个引用指向同一个对象
3. 如果希望垃圾回收机制回收某个对象，只需切断该对象的所有引用变量与该对象的联系即可
4. this关键字总是指向调用该方法的对象，其中构造器中的this是引用正在进行初始化的对象
5. **可以把this作为方法的返回值，返回该方法的对象**

## 方法知识点
1. java里的方法不能独立存在，必须定义在类内
2. java的方法的参数传递只有一种： **值传递**
3. **值传递的实质** ：系统为形参执行初始化，把实参变量的值赋给赋值给方法的形参变量，方法里操作的不是实际的实参变量
4. 当方法的参数传递的是一个引用类型的参数时，实际上是把 **实参变量的内容——对象的地址** ，复制给了形参变量，所以形参和实参指向同一个对象，在方法里操作形参，其实和在方法外操作实参是一样的
5. JDK1.5之后， **java允许定义形参个数可变的参数** ，方法为：在 **最后一个形参的类型后** 增加三点(...)，注意： **形参个数可变的那个形参，可以接受0个和1个形参** ，接受后的形参被当成 **数组** 处理
6. 形参个数可变的参数可以接收一个 **数组**
7. 方法 **重载** 要求两同一不同：同一个类中的同名方法，其形参列表不同。方法的其他部分与方法重载没有任何关系。

## 成员变量和局部变量知识点
1. 成员变量无需显示初始化，系统将在类的准备阶段或者创建该类的实例时进行默认初始化，其初始化的赋值规则与数组动态初始化时数组元素的赋值规则完全相同。
2. 局部变量包括： **形参，方法局部变量，代码块局部变量** 。
3. 局部变量除了形参，都必须显示初始化才能使用。
4. 代码块内的局部变量的作用域就只在当前代码块内。
5. 一个类不能定义两个同名的成员变量，即使一个是静态变量，一个是实例变量。
6. 一个方法里不不能定义两个同名的局部变量，即使一个是方法内局部变量，一个代码块局部变量或者形参。

## 隐藏和封装知识点
1. 访问控制级别由严格到宽松：private-\>default-\>protected-\>public。
2. 需要注意的是： **protected的访问权限比default宽松，protected修饰的成员可以被同一个包中的其他类访问，也可以被不同包中的子类访问** 。
3. 局部变量不能使用访问控制符修饰。
4. 如果一个java文件定义的所有类都没有使用public修饰，那么此java文件的命名可以是一切合法的文件名；但是如果一个java文件定义的类中有一个public修饰的类，那么此java文件只能与此类名相同。最后， **一个java文件最多只能由一个public修饰的类** 。
5. 一个java源文件只能定义一个包，即只能包含一个package语句。
6. import语句还有一个 **静态导入** 的方法：`import static package.subpackage...ClassName.*;`

## 构造器知识点
1. 通常将构造器的访问权限设置为public，但是有时也会设置为private，比如像构造一个单例类。
2. 可以在一个构造器中调用同类下的另外一个构造器，通过this()的形式调用，更加this的形参的不同调用不同的构造器。而且 **这条this()语句必须位于构造器执行体的第一条语句**

## 类继承的知识点
1. **java子类不能获得父类的构造器** 。
2. java的每个类最多只能有一个 **直接父类** 。
3. 如果一个java类没有显示指定任何直接父类，那么默认继承 `java.lang.Object` 类，所以此类时所有java类的父类。
4. 子类包含与父类同名的方法称为方法重写（Override），子类对象将无法访问父类中被重写/覆盖的方法，但可以在子类方法中调用父类被覆盖的方法（使用super语句或者父类的类名，其中通过父类类名调用的是被覆盖的父类的静态方法）。
5. 方法 **重写** 要求两同两小一大：形参列表和方法名相同；子类方法返回值类型和子类方法声明抛出的异常类应该比父类的更小或相等；子类的访问控制权限比父类的大。此外： **方法重写不能一个静态方法，一个实例方法** 
6. 如果父类的一个方法是private访问权限，但是子类写了一个同名同参的方法，这不算重写，这算子类自己扩展了一个新的方法。
7. **重载和重写的区别** ：重载主要发生在同一个类中的同名不同形参的方法之间（当然有父子关系的类也可能存在重载，因为子类会获取父类的方法），而重写主要发生在有父子关系的类的同名同参的方法之间。

## supper限定知识点
1. supper调用的都是父类的实例相关，不能调用其类相关，所有super不能出现在static修饰的方法中。
2. 当子类和父类有同名的属性的时候，可以通过 `suoer.父类属性` 来获取被覆盖的父类同名属性。如果被覆盖的是类变量，则可以通过父类名调用来获取。
3. 可以使用 `super()` 的形式在 **子类构造器中** 调用父类构造器，和 `this()` 的用法差不多，同样只能出现在构造器执行体的第一行，所以this()和super()不可能同时出现。
4. 当创建java对象时，总是会先调用一次父类的构造器，然后再执行子类的构造器。

## 多态知识点
1. **多态** 的发生条件就是 **运行时类型和编译时类型不一致，同时有重写的方法(非重载的方法)** ，运行时调用该引用变量的 **方法** 时， **其方法行为总是表现出子类方法的行为特征** 。
2. **对象的属性不具备多态性质** 。
3. **引用变量只能调用其编译时类型所具备的方法** ，但运行时调用的则是运行时类型所具备的方法。

## 类型转换知识点
1. 类型转换符就是: `()`
2. 基本类型转换只能在数值类型之间进行；引用类型转换只能发生在具有继承关系的两个类型之间，并且被转换的的引用变量的所引用的对象的实际类型必须就是将被转化后的类型才能完成强制类型转换（实质就是 **被强转变量所引用的对象得是被转化后类型的类的实例才行** ）。
3. 强转引用类型的变量时，可以先用 `instanceof` 运算符来来判断是否能够强转（此运算符用于判断前者对象是否是后者类的实例）。

## 其他知识点
1. **不要在父类构造器中调用将被子类覆盖的方法，否则将调用的是子类的重写后的方法** 。
2. 一个类里能够有多个初始化块，其执行顺序为其出现的顺序，但是一个类里的多个初始化块其实是没有意义的。
3. 初始化块如果有修饰符，那么只能是static。
4. 初始化块没有对应的标识符，显然不能被调用。
5. 初始化块（非静态）在创建类对象的时候隐式执行，并且执行顺序在构造器之前。
6. 对类的属性执行初始化操作时，其初始化顺序是：先执行初始化块和声明此属性指定的初始值（这两者的执行顺序与出现的顺序相同），再执行构造器里指定的值。
7. 静态初始化块在类初始化阶段执行静态初始化，不是在创建对象时进行初始化，并且 **只执行一次静态初始化** 。
8. 静态初始化块不能操作实例变量。
