---
typora-root-url: ../../../static
title: "数据类型和运算符"
date: 2019-09-04T22:48:36+08:00
draft: false
categories: ["Java"]
---

## 注释
1. 单行注释：使用`//`即可
2. 多行注释：使用`/*注释内容*/`即可
3. 文档注释：以`/**`开始，以`*/`结束

## 标识符和关键字
1. 允许一行书写多个语句，每个语句之间用封号隔开。
2. 一个语句可以跨越多行，但是**变量名和字符串不能跨越多行**
3. java的标识符以**大小写字母，下划线，数字和美元符组成，且数字不能打头**

## 数据类型分类
1. java是一种强数据类型
2. java支持的数据类型分为：**基本类型和引用类型**
3. 基本数据类型分为四类：
	1. 整数类型：byte(1字节),short(2字节),int(4字节),long(8字节)
	2. 字符类型：char(2字节)
	3. 浮点类型：float(4字节),double(8字节)
	4. 布尔类型：boolean(**1位**)

### 整型
1. 一个java整型常量默认就是int类型
2. 将一个较小的整型常量赋值给一个byte或者short，系统会自动把这个整数常量当成byte或者short处理。
3. 如果使用一个**巨大** 的整型常量，系统不会自动把这个整数当成long型处理。如果希望将这个整数常量当成一个long型处理，可以加一个`L`后缀（或者`l`后缀）
4. 如果将一个较小的整型常数（0~65535）赋值给char类型，系统会自动把这个整数当成char类型

测试如下：

	byte a=12;
	short b=13;
	int c=123456789;
	//此语句报错：Integer number too large，默认整型直接量为int类型，此时超过了int的范围
	//long cc=123456789123;
	//此语句才是正确的
	long cc=123456789123L;
	char d=97;  //系统自动将int类型的直接量当成了char处理，所以会输出97的Unicode码：a
	System.out.println(d);  //输出：a

### 字符型
**字符型常量** 有三种表示形式
1. 通过单个字符来直接指定字符型常量，例如`'a'`
2. 直接使用Unicode值来表示字符型常量，格式为`\u9999`,其中的数字是一个十六进制的整数
3. 通过转义字符表示特殊的字符型常量，例如`\n和\t`等

测试如下：

	char a=97;  //97这个int类型的整数常量被系统自动当成了char类型
	char b='a';
	char c='\u9999';
	char d='\t';
	char e='淦'; //通过单个字符指定字符常量，可以是汉字
	//将输出：a---a---香---	---淦
	System.out.println(a+"---"+b+"---"+c+"---"+d+"---"+e);  //'\t'代表水平制表符

### 浮点型
1. java采用二进制数据的科学计数法来表示浮点数，所以可能不能精确的表示一个浮点数。
2. 只有浮点类型的数值才能采用科学计数法，意思是科学计数法的表达式的结果是double类型的。
3. java的默认浮点数的类型是double类型的。如果希望浮点直接量当成float处理，可以加`F后缀`或`f后缀`
4. 有三个特殊的浮点数：正负无穷大，非数。例如，使用一个负的浮点数（如果是整数，就会报错的）除以0，得到负无穷大，反之为正无穷大，0.0除以0.0得到一个非数。此外，**所有的正无穷大都相等，所有的负无穷大都相等，NaN不等于任何数，甚至不与自己相等**

测试如下：

	double a=1222E2;
	//下面的b的赋值语句将报错，默认的浮点数直接量为double类型
	// 现在将double类型的值赋值给float，于是报错
	//float b=12.3;
	//这才是正确的书写格式
	float b=12.3F;
	double c=0.0/0.0;   //得到非数：NaN
	//将输出：122200.0---12.3---NaN
	System.out.println(a+"---"+b+"---"+c);
	//输出false，非数不与任何数相等,也不与自己相等
	System.out.println(c==c);
	//输出true，正无穷大都是相等的
	System.out.println(12.1/0==155/0.0);
	//输出true，负无穷大也都是相等的
	System.out.println((-12.1/0)==(-155/0.0));

### Java7新增数值书写特性
java7引入一个新的功能：可以在数值中使用下划线，不管是整型数值还是浮点数值。

测试如下：

	byte a=1_2;
	short b=1_2_3;
	int c=1_2_3_4;
	long d=1_2_3_4_5L;
	char e=9_7;
	//将输出：12---123---1234---12345---a
	System.out.println(a+"---"+b+"---"+c+"---"+d+"---"+e);

### 浮点型
**java的浮点型的值，不能用0和1代替，只能为true或者false** ；

## 基本类型的类型转换
### 自动类型转换
1. byte->short->int->long->float->double，从左到右可以直接自动类型转换，此外，char也是整型类型，虽然他是两个字节，范围比byte大，但是**不能直接从byte转到char** ，没有可以自动转为char的，只能char自动转为int，long，float或double。

### 强制类型转换
强制类型转换就是在允许的条件下，在被转对象前加一个`(被转类型)`，例如:`float a=(float)12.1;`

### 表达式自动类型提升
1. 所有的byte，short和char类型自动被提升为int类型。
2. 整个算术表达式的数据类型自动提升到与表达式中最高等级操作数相同的类型。
3. 表达式的类型将严格保持和表达式中最高等级操作数相同的类型。所有1/2的结果还是int类型，而不是double类型。

## 其他注意点
1. 当一个字符串由多个字符串常量连接而成时，它本身也是一个字符串常量。
2. 当一个程序第一次使用某个字符串直接量时，java将使用常量池来缓存该直接量，如果后续使用该字符串直接量，java将直接从常量池中拿取。
3. 求余运算的结果不一定总是整数，因为求余运算的操作数可以是小数。
4. 求余运算的两个操作数如果有一个或者两个是浮点数，则第二个操作数可以是0或者0.0，得到结果NaN。
5. 0或0.0对0以外的任何数求余都是0或0.0。